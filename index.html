<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>GPS History Tool</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<style>

:root{--panel:#ffffffcc;}

/* ===== GLOBAL ===== */

html,body{
  margin:0;
  height:100%;
  font-family:Inter,system-ui,Arial;
  overflow:hidden;
  background:
    radial-gradient(circle at 20% 20%, #e0e7ff 0%, transparent 40%),
    radial-gradient(circle at 80% 80%, #dbeafe 0%, transparent 40%),
    linear-gradient(180deg,#f8fafc,#eef2ff);
}

#app{
  display:flex;
  height:100%;
}

/* ===== LEFT PANEL ===== */

#left{
  width:320px;
  min-width:280px;
  max-width:560px;
  backdrop-filter:blur(14px);
  background:var(--panel);
  box-shadow:4px 0 20px rgba(0,0,0,.06);
  padding:8px;
  display:flex;
  flex-direction:column;
  gap:6px;
  user-select:none;
  font-size:12px;
}

/* ===== DIVIDER ===== */

#divider{
  width:6px;
  cursor:col-resize;
  background:linear-gradient(#c7d2fe,#818cf8,#c7d2fe);
}

/* ===== MAP ===== */

#mapWrap{
  flex:1;
  position:relative;
}

#map{
  height:100%;
}

#mapStyle{
  position:absolute;
  top:10px;
  right:10px;
  backdrop-filter:blur(10px);
  background:#ffffffcc;
  padding:6px 8px;
  border-radius:10px;
  z-index:999;
  font-size:11px;
}

/* ===== TEXTAREA ===== */

textarea{
  width:96%;
  height:76px;
  border-radius:8px;
  border:1px solid #e5e7eb;
  padding:5px;
  font-family:monospace;
  font-size:11px;
  resize:none;
  background:rgba(255,255,255,.6);
}

/* ===== BUTTON ===== */

button{
  padding:6px 8px;
  border:none;
  border-radius:9px;
  background:#2563eb;
  color:white;
  font-weight:600;
  font-size:12px;
  cursor:pointer;
}

button:hover{
  background:#1d4ed8;
}

/* ===== HEADING ===== */

h3{
  font-size:10px;
  color:#64748b;
  text-transform:uppercase;
  margin:3px 0;
}

/* ===== CARD ===== */

.card{
  background:rgba(255,255,255,.75);
  backdrop-filter:blur(10px);
  border:1px solid rgba(0,0,0,.05);
  border-radius:12px;
  padding:6px;
  display:flex;
  flex-direction:column;
  gap:4px;
}

/* ===== SLIDER ===== */

.slider-container{
  position:relative;
  width:100%;
  height:6px;
  background:#bfc6d4;
  border-radius:999px;
  margin:5px 0 8px;
}

.slider-progress{
  position:absolute;
  height:100%;
  background:linear-gradient(90deg,#2563eb,#60a5fa);
  border-radius:999px;
}

.slider-thumb-glass{
  position:absolute;
  top:50%;
  transform:translate(-50%,-50%);
  width:26px;
  height:16px;
  border-radius:999px;
  cursor:pointer;
  background:rgba(255,255,255,.7);
  backdrop-filter:blur(6px);
  border:1px solid rgba(255,255,255,.6);
  box-shadow:0 3px 8px rgba(0,0,0,.25);
  transition:.15s;
}

/* ===== LEAFLET ===== */

.leaflet-interactive{
  transition:stroke-width .15s ease;
}

/* ===== DRAG & DROP OVERLAY ===== */

#dropOverlay{
  position:fixed;
  inset:0;
  background:rgba(30,41,59,.75);
  backdrop-filter:blur(6px);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:9999;
}

#dropOverlay.active{
  display:flex;
}

#dropOverlay div{
  font-size:36px;
  font-weight:800;
  letter-spacing:2px;
  color:white;
  padding:32px 48px;
  border:4px dashed rgba(255,255,255,.7);
  border-radius:22px;
}

/* ===== CUSTOM FILE INPUT ===== */

#fileBtn{
  background:#2563eb;
  color:white;
  font-weight:600;
  border-radius:9px;
  padding:6px 8px;
  font-size:12px;
  cursor:pointer;
}

#fileBtn:hover{
  background:#1d4ed8;
}

#fileName{
  font-size:10px;
  color:#475569;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}

#pickerCard{
  grid-template-columns: 120px 1fr;
  row-gap:6px;
  column-gap:8px;
  align-items:center;
}

#pickerCard label{
  text-align:left;
}

#pickerCard select{
  width:100%;
}

#sheetRow,
#colRow{
  display:contents;
}

#loadingOverlay{
  position:fixed;
  inset:0;
  background:rgba(15,23,42,.6);
  backdrop-filter:blur(4px);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:99999;
}

#loadingOverlay.active{
  display:flex;
}

#loadingOverlay div{
  font-size:22px;
  font-weight:700;
  color:white;
  padding:20px 32px;
  background:rgba(0,0,0,.4);
  border-radius:14px;
}


</style>

</head>

<body>

<div id="dropOverlay">
  <div>DROP CSV FILE HERE</div>
</div>

<div id="loadingOverlay">
  <div>Loading file...</div>
</div>


<div id="app">

<div id="left">

<h3>Input Excel (longitude, latitude)</h3>
<textarea id="input" placeholder="Just paste here from excel table, example:
106,849176	-6,147265
106,848928	-6,145941
106,84873	-6,144903
"></textarea>

<button onclick="process()">Proceed</button>

<div class="card">
  <button type="button" id="fileBtn">Browse CSV File</button>
  <div id="fileName">No file selected</div>
  <input type="file" id="csvFile" accept=".csv,.xlsx" hidden>
</div>

<div class="card" id="pickerCard" style="display:none">

  <div id="sheetRow">
    <label>Sheet</label>
    <select id="sheetSelect"></select>
  </div>

  <div id="colRow">
    <label>Latitude</label>
    <select id="latSelect"></select>

    <label>Longitude</label>
    <select id="lonSelect"></select>
  </div>

</div>

<h3>Output</h3>
<textarea id="output" readonly></textarea>
<button onclick="plot()">Plot</button>

<div class="card">
<label><input type="checkbox" id="showPath" checked onchange="updateStyle()"> Show The Line</label>
<label>The Thickness of the Line: <span id="wval">4</span></label>

<div class="slider-container" data-target="weight" data-min="1" data-max="60" data-value="4">
<div class="slider-progress"></div>
<div class="slider-thumb-glass"></div>
</div>

<label>Line Color</label>
<input type="color" id="color" value="#ff0000" oninput="updateStyle()">
</div>

<div class="card">
<label><input type="checkbox" id="showPoints" checked onchange="updateStyle()"> Show Dot Point</label>
<label>Dot Size: <span id="pval">5</span></label>

<div class="slider-container" data-target="pointSize" data-min="1" data-max="30" data-value="5">
<div class="slider-progress"></div>
<div class="slider-thumb-glass"></div>
</div>

<label>Dot Color</label>
<input type="color" id="pointColor" value="#0000ff" oninput="updateStyle()">
</div>

<button onclick="clearAll()">Clear</button>

</div>

<div id="divider"></div>

<div id="mapWrap">
<div id="mapStyle">
<label><input type="radio" name="bm" checked onchange="setMap('osm')"> OSM</label>
<label><input type="radio" name="bm" onchange="setMap('sat')"> Satellite</label>
<label><input type="radio" name="bm" onchange="setMap('hybrid')"> Hybrid</label>
<label><input type="radio" name="bm" onchange="setMap('voyager')"> Voyager</label>
<label><input type="radio" name="bm" onchange="setMap('light')"> Light</label>
<label><input type="radio" name="bm" onchange="setMap('dark')"> Dark</label>
<label><input type="radio" name="bm" onchange="setMap('topo')"> Topo</label>
</div>
<div id="map"></div>
</div>

</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<script>

const loadingOverlay = document.getElementById("loadingOverlay");

function showLoading(){
  loadingOverlay.classList.add("active");
}

function hideLoading(){
  loadingOverlay.classList.remove("active");
}

let workbook = null;
let sheetRows = [];
let forcePicker = false;

/* ===== MAP & EXISTING LOGIC (TIDAK DIUBAH) ===== */

const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png');

const esri = L.tileLayer(
'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
);

// OSM Labels (roads + place names for hybrid)
const osmLabels = L.tileLayer(
'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
{ opacity: 0.6 }
);

// CARTO Light
const cartoLight = L.tileLayer(
'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png'
);

// CARTO Dark
const cartoDark = L.tileLayer(
'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'
);

// OpenTopoMap
const topo = L.tileLayer(
'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png'
);

// Carto Voyager (Google-like roads)
const voyager = L.tileLayer(
'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png'
);

// Stamen Terrain
const terrain = L.tileLayer(
  'https://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}.png',
  {
    subdomains: 'abcd',
    attribution: 'Map tiles by Stamen Design, CC BY 3.0 — OSM'
  }
);


// ESRI Hybrid (satellite + labels)
const esriLabels = L.tileLayer(
'https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}'
);

const map=L.map('map',{center:[-6.2,106.8],zoom:13,layers:[osm]});


const layer=L.layerGroup().addTo(map);

// PANES
map.createPane('linePane');
map.createPane('pointPane');
map.createPane('flagPane');

map.getPane('linePane').style.zIndex = 400;
map.getPane('pointPane').style.zIndex = 500;
map.getPane('flagPane').style.zIndex = 600;

let activePopup = null;

/* ===== LOGIC KERNEL SESUAI FLOW ===== */

const kernel = {
  rawCoords: [],          // data mentah
  visibleSegments: [],    // hasil akhir untuk digambar
  lines: [],
  points: [],
  startMarker: null,
  endMarker: null,

  // ===== STATEFUL VARIABLE =====
  lastPacketTime: null,
  lastStatus: null,       // "realtime" | "buffer"
  skipLocationTime: null
};

function distanceMeter(a, b){
  const R = 6371000;
  const dLat = (b.lat - a.lat) * Math.PI/180;
  const dLon = (b.lon - a.lon) * Math.PI/180;
  const la1 = a.lat * Math.PI/180;
  const la2 = b.lat * Math.PI/180;

  const x = Math.sin(dLat/2)**2 +
            Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;

  return 2 * R * Math.asin(Math.sqrt(x));
}

function deduplicateCoords(coords, timeThreshold = 2000) {
  if (!coords.length) return [];

  const result = [];
  let prev = null;

  coords.forEach(p => {
    if (!prev) {
      result.push(p);
      prev = p;
      return;
    }

    const sameCoord =
      Math.abs(p.lat - prev.lat) < 1e-6 &&
      Math.abs(p.lon - prev.lon) < 1e-6;

    const timeDiff = Math.abs(p.time - prev.time);

    // === CASE 1: buffer vs realtime di waktu sama ===
    if (sameCoord && timeDiff <= timeThreshold) {
      // realtime menang
      if (prev.status === "buffer" && p.status === "realtime") {
        result[result.length - 1] = p;
        prev = p;
        return;
      }
      // buffer kalah
      if (prev.status === "realtime" && p.status === "buffer") {
        return;
      }
      // dua-duanya sama (buffer-buffer / realtime-realtime)
      return;
    }

    result.push(p);
    prev = p;
  });

  return result;
}

function kernelProcess(){

  kernel.visibleSegments = [];
  let segment = [];
  let prev = null;

  kernel.rawCoords.forEach(p => {

    // 1. BUFFER TIDAK DIGAMBAR
    if(p.status === "buffer"){
      prev = p;
      if(segment.length > 1){
        kernel.visibleSegments.push(segment);
        segment = [];
      }
      return;
    }

    if(prev){
      const timeGap = p.time - prev.time;
      const dist = distanceMeter(prev, p);

      // 2. PUTUS SEGMENT JIKA TIME GAP
      if(timeGap > kernel.maxTimeGap){
        if(segment.length > 1) kernel.visibleSegments.push(segment);
        segment = [];
      }

      // 3. PUTUS SEGMENT JIKA LOMPAT JARAK
      else if(dist > kernel.maxJumpMeter){
        if(segment.length > 1) kernel.visibleSegments.push(segment);
        segment = [];
      }
    }

    segment.push(p);
    prev = p;
  });

  if(segment.length > 1){
    kernel.visibleSegments.push(segment);
  }
}

function kernelRender(){
  layer.clearLayers();

  kernel.lines = [];
  kernel.points = [];
  kernel.startMarker = null;
  kernel.endMarker = null;

  if(!kernel.visibleSegments.length) return;

  // gambar garis per segmen
  kernel.visibleSegments.forEach(seg=>{
    const line = L.polyline(
      seg.map(p=>[p.lat,p.lon]),
      { pane:"linePane" }
    ).addTo(layer);

    kernel.lines.push(line);

// gambar titik + tooltip
seg.forEach(p=>{

  const dot = L.circleMarker(
    [p.lat,p.lon],
    { pane:"pointPane" }
  ).addTo(layer);

      // format waktu
      let timeStr = "-";
      if(p.time){
        const d = new Date(p.time);
        timeStr = d.toISOString().replace("T"," ").substring(0,19);
      }

      dot.bindTooltip(
        `
        <div style="font-size:11px">
          <b>Latitude:</b> ${p.lat.toFixed(6)}<br>
          <b>Longitude:</b> ${p.lon.toFixed(6)}<br>
          <b>Time:</b> ${timeStr}<br>
          <b>Status:</b> ${p.status || "-"}
        </div>
        `,
        {
          direction: "top",
          offset: [0,-5],
          opacity: 0.95
        }
      );

      dot.on("click", function(e){

        e.originalEvent.stopPropagation();

        if(activePopup){
          map.closePopup(activePopup);
        }

        let timeStr = "-";
        if(p.time){
          const d = new Date(p.time);
          timeStr = d.toISOString().replace("T"," ").substring(0,19);
        }

        activePopup = L.popup({
          closeButton:false,
          autoClose:true,     // <-- ubah
          closeOnClick:true,  // <-- ubah
          offset:[0,-10]
        })
        .setLatLng([p.lat,p.lon])
        .setContent(`
          <div style="font-size:12px">
            <b>Latitude:</b> ${p.lat.toFixed(6)}<br>
            <b>Longitude:</b> ${p.lon.toFixed(6)}<br>
            <b>Time:</b> ${timeStr}<br>
            <b>Status:</b> ${p.status || "-"}
          </div>
        `)
        .openOn(map);

      });

      kernel.points.push(dot);
    });

  });

  // start marker = titik pertama segmen pertama
  const first = kernel.visibleSegments[0][0];
  kernel.startMarker = L.marker(
    [first.lat, first.lon],
    { icon:startIcon, pane:"flagPane" }
  ).addTo(layer);

  // end marker = titik terakhir segmen terakhir
  const lastSeg = kernel.visibleSegments[kernel.visibleSegments.length-1];
  const last = lastSeg[lastSeg.length-1];
  kernel.endMarker = L.marker(
    [last.lat, last.lon],
    { icon:finishIcon, pane:"flagPane" }
  ).addTo(layer);

  // zoom map
  const all = kernel.visibleSegments.flat().map(p=>[p.lat,p.lon]);
  map.fitBounds(all);
}

function kernelApplyStyle() {

  kernel.lines.forEach(line=>{
    line.setStyle({
      color: color.value,
      weight: +window.weight.value,
      opacity: showPath.checked ? 1 : 0
    });
  });

  kernel.points.forEach(p=>{
    p.setRadius(+window.pointSize.value);
    p.setStyle({
      color: pointColor.value,
      fillColor: pointColor.value,
      fillOpacity: showPoints.checked ? 1 : 0,
      opacity: showPoints.checked ? 1 : 0
    });
  });

}

function setMap(t){
  map.eachLayer(l=>map.removeLayer(l));

  if(t==="osm") osm.addTo(map);

  if(t==="sat") esri.addTo(map);

  if(t==="hybrid"){
    esri.addTo(map);
    osmLabels.addTo(map);
  }

  if(t==="voyager") voyager.addTo(map);

  if(t==="light") cartoLight.addTo(map);

  if(t==="dark") cartoDark.addTo(map);

  if(t==="topo") topo.addTo(map);

  layer.addTo(map);
}

const divider=document.getElementById("divider");
const left=document.getElementById("left");
let resizing=false;

divider.onmousedown=()=>resizing=true;
window.onmouseup=()=>resizing=false;

window.onmousemove=e=>{
  if(!resizing) return;
  left.style.width=Math.max(300,Math.min(600,e.clientX))+"px";
  map.invalidateSize();
};

function normalizeCoord(v){
  if(v === undefined || v === null) return NaN;

  if(typeof v === "number") return v;

  v = v.toString().trim();

  if(v === "") return NaN;

  // ganti semua koma jadi titik
  v = v.replace(/,/g,".");

  return parseFloat(v);
}


function clean(v){
  return normalizeCoord(v);
}


function process(){

  // GUARD: jangan override hasil CSV/XLSX
  if(!input.value.trim()) return;

  let c=1,out=[];
  input.value.split('\n').forEach(l=>{
    if(!l) return;
    let p=l.trim().split(/\s+/);
    out.push(c+"."+clean(p[1])+","+clean(p[0]));
    c++;
  });
  output.value=out.join("\n");
}

const startIcon = L.divIcon({
  className:"",
  html:`
  <svg width="40" height="40" viewBox="0 0 40 40">
    <!-- pole -->
    <rect x="6" y="2" width="3" height="36" fill="#065f46"/>
    <!-- flag -->
    <path d="M9 4 
             C22 6, 26 12, 36 10
             L36 22
             C26 24, 22 18, 9 20 Z"
          fill="#22c55e"
          stroke="#065f46"
          stroke-width="1.5"/>
  </svg>
  `,
  iconSize:[40,40],
  iconAnchor:[6,38]
});

const finishIcon = L.divIcon({
  className:"",
  html:`
  <svg width="40" height="40" viewBox="0 0 40 40">
    <!-- pole -->
    <rect x="6" y="2" width="3" height="36" fill="#111"/>
    <!-- checkered flag -->
    <g transform="translate(9,4)">
      <rect x="0" y="0" width="24" height="18" fill="#fff"/>
      <!-- black squares -->
      <rect x="0" y="0" width="6" height="6" fill="#000"/>
      <rect x="12" y="0" width="6" height="6" fill="#000"/>
      <rect x="6" y="6" width="6" height="6" fill="#000"/>
      <rect x="18" y="6" width="6" height="6" fill="#000"/>
      <rect x="0" y="12" width="6" height="6" fill="#000"/>
      <rect x="12" y="12" width="6" height="6" fill="#000"/>
      <rect x="24" y="0" width="4" height="18" fill="#000"/>
    </g>
  </svg>
  `,
  iconSize:[40,40],
  iconAnchor:[6,38]
});

function plot(){

  // fallback: ambil dari textarea output kalau kernel kosong
  if(!kernel.rawCoords.length && output.value.trim()){
    kernel.rawCoords = [];

    output.value.split('\n').forEach(l=>{
      l = l.replace(/^\d+\./,'');
      if(!l) return;
      const [lat,lon] = l.split(',').map(Number);
      if(
        isNaN(lat) || 
        isNaN(lon) ||
        lat < -90 || lat > 90 ||
        lon < -180 || lon > 180 ||
        (lat === 0 && lon === 0)
      ) return;


      kernel.rawCoords.push({
        lat,
        lon,
        time: Date.now() // dummy time (manual input)
      });
    });
  }

  if(!kernel.rawCoords.length){
    alert("No data to plot");
    return;
  }

  kernel.rawCoords = deduplicateCoords(kernel.rawCoords);
  kernelProcess();
  kernelRender();
  kernelApplyStyle();
}

function updateStyle() {
  kernelApplyStyle();
}


function clearAll(){
  layer.clearLayers();

  input.value="";
  output.value="";
  csvFile.value="";
  fileName.innerText="No file selected";

  pickerCard.style.display="none";

  map.setView([-6.2,106.8],13);

  kernel.rawCoords = [];
  kernel.visibleSegments = [];
  kernel.lines = [];
  kernel.points = [];
  kernel.startMarker = null;
  kernel.endMarker = null;
}

/* ===== CSV PARSER (BARU) ===== */

function parseCSV(file){
 showLoading();
 Papa.parse(file,{
  header:true,
  skipEmptyLines:true,
  complete:r=>{

   const headers = Object.keys(r.data[0]||{});
    // === SORT BY received_on (UTC) ===
    r.data.sort((a,b)=>{
      const ta = new Date(a.packet_location || a.time || a.received_on).getTime();
      const tb = new Date(b.packet_location || b.time || b.received_on).getTime();
      return ta - tb;
    });
   const latKey = headers.find(h=>h.toLowerCase().includes("lat"));
   const lonKey = headers.find(h=>h.toLowerCase().includes("lon") || h.toLowerCase().includes("lng"));
    kernel.rawCoords = [];

    r.data.forEach(row=>{
      const lat = normalizeCoord(row[latKey]);
      const lon = normalizeCoord(row[lonKey]);

      const eventTime = new Date(
        row.packet_location || row.time || row.received_on
      ).getTime();

      if(isNaN(lat)||isNaN(lon)) return;

      let time = isNaN(eventTime) ? Date.now() : eventTime;


      kernel.rawCoords.push({
        lat,
        lon,
        time,
        status: row.status_data === "0704" ? "buffer" : "realtime"
      });

    });

   // AUTO DETECT OK
   if(latKey && lonKey){

     pickerCard.style.display="none";

     let out=[],c=1;

     r.data.forEach(row=>{
       const lat=normalizeCoord(row[latKey]);
       const lon=normalizeCoord(row[lonKey]);
       if(isNaN(lat)||isNaN(lon)) return;
       out.push(`${c}.${lat},${lon}`);
       c++;
     });

     output.value=out.join("\n");
     return;
   }

   // AUTO FAIL → tampil picker
   pickerCard.style.display="grid";

   latSelect.innerHTML=headers.map(h=>`<option>${h}</option>`).join("");
   lonSelect.innerHTML=headers.map(h=>`<option>${h}</option>`).join("");

   function run(){
     let out=[],c=1;
     r.data.forEach(row=>{
       const lat=normalizeCoord(row[latSelect.value]);
       const lon=normalizeCoord(row[lonSelect.value]);
       if(isNaN(lat)||isNaN(lon)) return;
       out.push(`${c}.${lat},${lon}`);
       c++;
     });
     output.value=out.join("\n");
   }

   latSelect.onchange=run;
   lonSelect.onchange=run;
   run();
   hideLoading();
  }
 });
}

csvFile.onchange=e=>{
  if(e.target.files[0]) parseCSV(e.target.files[0]);
};

const fileBtn = document.getElementById("fileBtn");
const fileName = document.getElementById("fileName");

fileBtn.onclick = () => csvFile.click();

csvFile.onchange = e => {
  const file = e.target.files[0];
  if(!file) return;

  fileName.innerText = file.name;

  const ext = file.name.split('.').pop().toLowerCase();

  if(ext === "csv"){
    parseCSV(file);
  }else if(ext === "xlsx"){
    parseXLSX(file);
  }else{
    alert("Unsupported file format");
  }
};

function parseXLSX(file){
  showLoading();
  const reader=new FileReader();

  reader.onload=e=>{
    const wb=XLSX.read(new Uint8Array(e.target.result),{type:"array"});
    workbook=wb;

    forcePicker = wb.SheetNames.length > 1;

    sheetRow.style.display = forcePicker ? "contents" : "none";

    // RESET dulu
    sheetSelect.innerHTML = "";

    // baru isi ulang
    wb.SheetNames.forEach(n=>{
      sheetSelect.innerHTML += `<option>${n}</option>`;
    });


    pickerCard.style.display="grid";
    loadSheet();
    hideLoading();
  };

  reader.readAsArrayBuffer(file);
}

sheetSelect.onchange=loadSheet;

function loadSheet(){

  const sheet = workbook.Sheets[sheetSelect.value];
  sheetRows = XLSX.utils.sheet_to_json(sheet,{defval:""});

  if(!sheetRows.length) return;

  latSelect.innerHTML="";
  lonSelect.innerHTML="";

  Object.keys(sheetRows[0]).forEach(k=>{

    const o1=document.createElement("option");
    o1.value=k;
    o1.textContent=k;
    latSelect.appendChild(o1);

    const o2=document.createElement("option");
    o2.value=k;
    o2.textContent=k;
    lonSelect.appendChild(o2);
  });

  // auto detect
  let foundLat=false,foundLon=false;

  Object.keys(sheetRows[0]).forEach((k,i)=>{
    if(k.toLowerCase().includes("lat")){
      latSelect.selectedIndex=i;
      foundLat=true;
    }
    if(k.toLowerCase().includes("lon")){
      lonSelect.selectedIndex=i;
      foundLon=true;
    }
  });

  if(foundLat && foundLon){

    // kalau XLSX punya lebih dari 1 sheet → picker tetap tampil
    if(forcePicker){
      pickerCard.style.display="grid";
    }else{
      pickerCard.style.display="none";
    }

  }

  processSheet();
  }

latSelect.onchange = processSheet;
lonSelect.onchange = processSheet;

function processSheet(){

  const latCol = latSelect.value;
  const lonCol = lonSelect.value;

  kernel.rawCoords = [];
  let out = [], c = 1;

  sheetRows
    .map(r => {
      const lat = normalizeCoord(r[latCol]);
      const lon = normalizeCoord(r[lonCol]);

      let rawTime = r.packet_location || r.time || r.received_on;

      let time = rawTime ? new Date(rawTime).getTime() : Date.now();

      if (
        isNaN(lat) ||
        isNaN(lon) ||
        lat < -90 || lat > 90 ||
        lon < -180 || lon > 180 ||
        (lat === 0 && lon === 0)
      ) return null;


      if (isNaN(time)) time = Date.now();


      return {
        lat,
        lon,
        time,
        status: r.status_data === "0704" ? "buffer" : "realtime"
      };
    })
    .filter(Boolean)
    .sort((a,b)=>a.time-b.time)
    .forEach(p=>{
      kernel.rawCoords.push(p);
      out.push(`${c}.${p.lat},${p.lon}`);
      c++;
    });

  output.value = out.join("\n");
}


/* ===== GLOBAL DRAG & DROP ===== */

const overlay=document.getElementById("dropOverlay");
let dragCount=0;

window.addEventListener("dragenter",e=>{
  e.preventDefault();
  dragCount++;
  overlay.classList.add("active");
});

window.addEventListener("dragover",e=>e.preventDefault());

window.addEventListener("dragleave",e=>{
  dragCount--;
  if(dragCount<=0){
    overlay.classList.remove("active");
    dragCount=0;
  }
});

window.addEventListener("drop",e=>{
  e.preventDefault();
  overlay.classList.remove("active");
  dragCount=0;

  const f = e.dataTransfer.files[0];
  if(!f) return;

  fileName.innerText = f.name;

  const ext = f.name.split('.').pop().toLowerCase();

  if(ext === "csv"){
    parseCSV(f);
  }else if(ext === "xlsx"){
    parseXLSX(f);
  }
});


/* ===== SLIDER (TIDAK DIUBAH) ===== */

document.querySelectorAll('.slider-container').forEach(s=>{
  const thumb=s.querySelector('.slider-thumb-glass');
  const prog=s.querySelector('.slider-progress');
  const min=+s.dataset.min,max=+s.dataset.max;
  let val=+s.dataset.value;

  function render(){
    const pct=(val-min)/(max-min)*100;
    prog.style.width=pct+"%";
    thumb.style.left=pct+"%";
    if(s.dataset.target==="weight"){window.weight={value:val};wval.innerText=val;}
    if(s.dataset.target==="pointSize"){window.pointSize={value:val};pval.innerText=val;}
    updateStyle();
  }
  render();

  let drag=false;
  thumb.onmousedown=()=>drag=true;
  window.addEventListener("mouseup",()=>drag=false);
  window.addEventListener("mousemove",e=>{
    if(!drag) return;
    const r=s.getBoundingClientRect();
    val=Math.round(min+Math.min(Math.max(0,e.clientX-r.left),r.width)/r.width*(max-min));
    render();
  });
});

</script>
</body>
</html>
